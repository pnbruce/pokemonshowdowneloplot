"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackEventPoller = void 0;
class StackEventPoller {
    constructor(cfn, props) {
        this.cfn = cfn;
        this.props = props;
        this.events = [];
        this.complete = false;
        this.eventIds = new Set();
        this.nestedStackPollers = {};
    }
    /**
     * From all accumulated events, return only the errors
     */
    get resourceErrors() {
        return this.events.filter((e) => e.event.ResourceStatus?.endsWith('_FAILED') && !e.isStackEvent);
    }
    /**
     * Poll for new stack events
     *
     * Will not return events older than events indicated by the constructor filters.
     *
     * Recurses into nested stacks, and returns events old-to-new.
     */
    async poll() {
        const events = await this.doPoll();
        // Also poll all nested stacks we're currently tracking
        for (const [logicalId, poller] of Object.entries(this.nestedStackPollers)) {
            events.push(...(await poller.poll()));
            if (poller.complete) {
                delete this.nestedStackPollers[logicalId];
            }
        }
        // Return what we have so far
        events.sort((a, b) => a.event.Timestamp.valueOf() - b.event.Timestamp.valueOf());
        this.events.push(...events);
        return events;
    }
    async doPoll() {
        const events = [];
        try {
            const eventList = await this.cfn.describeStackEvents({
                StackName: this.props.stackName,
            });
            for (const event of eventList) {
                // Event from before we were interested in 'em
                if (this.props.startTime !== undefined && event.Timestamp.valueOf() < this.props.startTime) {
                    return events;
                }
                // Already seen this one
                if (this.eventIds.has(event.EventId)) {
                    return events;
                }
                this.eventIds.add(event.EventId);
                // The events for the stack itself are also included next to events about resources; we can test for them in this way.
                const isParentStackEvent = event.PhysicalResourceId === event.StackId;
                if (isParentStackEvent && this.props.stackStatuses?.includes(event.ResourceStatus ?? '')) {
                    return events;
                }
                // Fresh event
                const resEvent = {
                    event: event,
                    parentStackLogicalIds: this.props.parentStackLogicalIds ?? [],
                    isStackEvent: isParentStackEvent,
                };
                events.push(resEvent);
                if (!isParentStackEvent &&
                    event.ResourceType === 'AWS::CloudFormation::Stack' &&
                    isStackBeginOperationState(event.ResourceStatus)) {
                    // If the event is not for `this` stack and has a physical resource Id, recursively call for events in the nested stack
                    this.trackNestedStack(event, [...(this.props.parentStackLogicalIds ?? []), event.LogicalResourceId ?? '']);
                }
                if (isParentStackEvent && isStackTerminalState(event.ResourceStatus)) {
                    this.complete = true;
                }
            }
        }
        catch (e) {
            if (!(e.name === 'ValidationError' && e.message === `Stack [${this.props.stackName}] does not exist`)) {
                throw e;
            }
        }
        // // Also poll all nested stacks we're currently tracking
        // for (const [logicalId, poller] of Object.entries(this.nestedStackPollers)) {
        //   events.push(...(await poller.poll()));
        //   if (poller.complete) {
        //     delete this.nestedStackPollers[logicalId];
        //   }
        // }
        // // Return what we have so far
        // events.sort((a, b) => a.event.Timestamp!.valueOf() - b.event.Timestamp!.valueOf());
        // this.events.push(...events);
        return events;
    }
    /**
     * On the CREATE_IN_PROGRESS, UPDATE_IN_PROGRESS, DELETE_IN_PROGRESS event of a nested stack, poll the nested stack updates
     */
    trackNestedStack(event, parentStackLogicalIds) {
        const logicalId = event.LogicalResourceId;
        const physicalResourceId = event.PhysicalResourceId;
        // The CREATE_IN_PROGRESS event for a Nested Stack is emitted twice; first without a PhysicalResourceId
        // and then with. Ignore this event if we don't have that property yet.
        //
        // (At this point, I also don't trust that logicalId is always going to be there so validate that as well)
        if (!logicalId || !physicalResourceId) {
            return;
        }
        if (!this.nestedStackPollers[logicalId]) {
            this.nestedStackPollers[logicalId] = new StackEventPoller(this.cfn, {
                stackName: physicalResourceId,
                parentStackLogicalIds: parentStackLogicalIds,
                startTime: event.Timestamp.valueOf(),
            });
        }
    }
}
exports.StackEventPoller = StackEventPoller;
function isStackBeginOperationState(state) {
    return [
        'CREATE_IN_PROGRESS',
        'UPDATE_IN_PROGRESS',
        'DELETE_IN_PROGRESS',
        'UPDATE_ROLLBACK_IN_PROGRESS',
        'ROLLBACK_IN_PROGRESS',
    ].includes(state ?? '');
}
function isStackTerminalState(state) {
    return !(state ?? '').endsWith('_IN_PROGRESS');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2stZXZlbnQtcG9sbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3RhY2stZXZlbnQtcG9sbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQTRDQSxNQUFhLGdCQUFnQjtJQU8zQixZQUNtQixHQUEwQixFQUMxQixLQUE0QjtRQUQ1QixRQUFHLEdBQUgsR0FBRyxDQUF1QjtRQUMxQixVQUFLLEdBQUwsS0FBSyxDQUF1QjtRQVIvQixXQUFNLEdBQW9CLEVBQUUsQ0FBQztRQUN0QyxhQUFRLEdBQVksS0FBSyxDQUFDO1FBRWhCLGFBQVEsR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQzdCLHVCQUFrQixHQUFxQyxFQUFFLENBQUM7SUFLeEUsQ0FBQztJQUVKOztPQUVHO0lBQ0gsSUFBVyxjQUFjO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNuRyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksS0FBSyxDQUFDLElBQUk7UUFDZixNQUFNLE1BQU0sR0FBb0IsTUFBTSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFcEQsdURBQXVEO1FBQ3ZELEtBQUssTUFBTSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLENBQUM7WUFDMUUsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLElBQUksTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUNwQixPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztZ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QUFDMUIsQ0FBQztBQUVELFNBQVMsb0JBQW9CLENBQUMsS0FBeUI7SUFDckQsT0FBTyxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUNqRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBTdGFja0V2ZW50IH0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LWNsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB0eXBlIHsgSUNsb3VkRm9ybWF0aW9uQ2xpZW50IH0gZnJvbSAnLi4vLi4vYXdzLWF1dGgnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YWNrRXZlbnRQb2xsZXJQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgc3RhY2sgdG8gcG9sbFxuICAgKi9cbiAgcmVhZG9ubHkgc3RhY2tOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElEcyBvZiBwYXJlbnQgc3RhY2tzIG9mIHRoaXMgcmVzb3VyY2UsIGluIGNhc2Ugb2YgcmVzb3VyY2VzIGluIG5lc3RlZCBzdGFja3NcbiAgICovXG4gIHJlYWRvbmx5IHBhcmVudFN0YWNrTG9naWNhbElkcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBUaW1lc3RhbXAgZm9yIHRoZSBvbGRlc3QgZXZlbnQgd2UncmUgaW50ZXJlc3RlZCBpblxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFJlYWQgYWxsIGV2ZW50c1xuICAgKi9cbiAgcmVhZG9ubHkgc3RhcnRUaW1lPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTdG9wIHJlYWRpbmcgd2hlbiB3ZSBzZWUgdGhlIHN0YWNrIGVudGVyaW5nIHRoaXMgc3RhdHVzXG4gICAqXG4gICAqIFNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSBgQ1JFQVRFX0lOX1BST0dSRVNTYCwgYFVQREFURV9JTl9QUk9HUkVTU2AsXG4gICAqIGBERUxFVEVfSU5fUFJPR1JFU1MsIGBST0xMQkFDS19JTl9QUk9HUkVTU2AuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gUmVhZCBhbGwgZXZlbnRzXG4gICAqL1xuICByZWFkb25seSBzdGFja1N0YXR1c2VzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VFdmVudCB7XG4gIHJlYWRvbmx5IGV2ZW50OiBTdGFja0V2ZW50O1xuICByZWFkb25seSBwYXJlbnRTdGFja0xvZ2ljYWxJZHM6IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgZXZlbnQgcmVnYXJkcyB0aGUgcm9vdCBzdGFja1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgaXNTdGFja0V2ZW50PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIFN0YWNrRXZlbnRQb2xsZXIge1xuICBwdWJsaWMgcmVhZG9ubHkgZXZlbnRzOiBSZXNvdXJjZUV2ZW50W10gPSBbXTtcbiAgcHVibGljIGNvbXBsZXRlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBldmVudElkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBwcml2YXRlIHJlYWRvbmx5IG5lc3RlZFN0YWNrUG9sbGVyczogUmVjb3JkPHN0cmluZywgU3RhY2tFdmVudFBvbGxlcj4gPSB7fTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNmbjogSUNsb3VkRm9ybWF0aW9uQ2xpZW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IFN0YWNrRXZlbnRQb2xsZXJQcm9wcyxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBGcm9tIGFsbCBhY2N1bXVsYXRlZCBldmVudHMsIHJldHVybiBvbmx5IHRoZSBlcnJvcnNcbiAgICovXG4gIHB1YmxpYyBnZXQgcmVzb3VyY2VFcnJvcnMoKTogUmVzb3VyY2VFdmVudFtdIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudHMuZmlsdGVyKChlKSA9PiBlLmV2ZW50LlJlc291cmNlU3RhdHVzPy5lbmRzV2l0aCgnX0ZBSUxFRCcpICYmICFlLmlzU3RhY2tFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogUG9sbCBmb3IgbmV3IHN0YWNrIGV2ZW50c1xuICAgKlxuICAgKiBXaWxsIG5vdCByZXR1cm4gZXZlbnRzIG9sZGVyIHRoYW4gZXZlbnRzIGluZGljYXRlZCBieSB0aGUgY29uc3RydWN0b3IgZmlsdGVycy5cbiAgICpcbiAgICogUmVjdXJzZXMgaW50byBuZXN0ZWQgc3RhY2tzLCBhbmQgcmV0dXJucyBldmVudHMgb2xkLXRvLW5ldy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBwb2xsKCk6IFByb21pc2U8UmVzb3VyY2VFdmVudFtdPiB7XG4gICAgY29uc3QgZXZlbnRzOiBSZXNvdXJjZUV2ZW50W10gPSBhd2FpdCB0aGlzLmRvUG9sbCgpO1xuXG4gICAgLy8gQWxzbyBwb2xsIGFsbCBuZXN0ZWQgc3RhY2tzIHdlJ3JlIGN1cnJlbnRseSB0cmFja2luZ1xuICAgIGZvciAoY29uc3QgW2xvZ2ljYWxJZCwgcG9sbGVyXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLm5lc3RlZFN0YWNrUG9sbGVycykpIHtcbiAgICAgIGV2ZW50cy5wdXNoKC4uLihhd2FpdCBwb2xsZXIucG9sbCgpKSk7XG4gICAgICBpZiAocG9sbGVyLmNvbXBsZXRlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm5lc3RlZFN0YWNrUG9sbGVyc1tsb2dpY2FsSWRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB3aGF0IHdlIGhhdmUgc28gZmFyXG4gICAgZXZlbnRzLnNvcnQoKGEsIGIpID0+IGEuZXZlbnQuVGltZXN0YW1wIS52YWx1ZU9mKCkgLSBiLmV2ZW50LlRpbWVzdGFtcCEudmFsdWVPZigpKTtcbiAgICB0aGlzLmV2ZW50cy5wdXNoKC4uLmV2ZW50cyk7XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZG9Qb2xsKCk6IFByb21pc2U8UmVzb3VyY2VFdmVudFtdPiB7XG4gICAgY29uc3QgZXZlbnRzOiBSZXNvdXJjZUV2ZW50W10gPSBbXTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnRMaXN0ID0gYXdhaXQgdGhpcy5jZm4uZGVzY3JpYmVTdGFja0V2ZW50cyh7XG4gICAgICAgIFN0YWNrTmFtZTogdGhpcy5wcm9wcy5zdGFja05hbWUsXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRMaXN0KSB7XG4gICAgICAgIC8vIEV2ZW50IGZyb20gYmVmb3JlIHdlIHdlcmUgaW50ZXJlc3RlZCBpbiAnZW1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgJiYgZXZlbnQuVGltZXN0YW1wIS52YWx1ZU9mKCkgPCB0aGlzLnByb3BzLnN0YXJ0VGltZSkge1xuICAgICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbHJlYWR5IHNlZW4gdGhpcyBvbmVcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRJZHMuaGFzKGV2ZW50LkV2ZW50SWQhKSkge1xuICAgICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudElkcy5hZGQoZXZlbnQuRXZlbnRJZCEpO1xuXG4gICAgICAgIC8vIFRoZSBldmVudHMgZm9yIHRoZSBzdGFjayBpdHNlbGYgYXJlIGFsc28gaW5jbHVkZWQgbmV4dCB0byBldmVudHMgYWJvdXQgcmVzb3VyY2VzOyB3ZSBjYW4gdGVzdCBmb3IgdGhlbSBpbiB0aGlzIHdheS5cbiAgICAgICAgY29uc3QgaXNQYXJlbnRTdGFja0V2ZW50ID0gZXZlbnQuUGh5c2ljYWxSZXNvdXJjZUlkID09PSBldmVudC5TdGFja0lkO1xuXG4gICAgICAgIGlmIChpc1BhcmVudFN0YWNrRXZlbnQgJiYgdGhpcy5wcm9wcy5zdGFja1N0YXR1c2VzPy5pbmNsdWRlcyhldmVudC5SZXNvdXJjZVN0YXR1cyA/PyAnJykpIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRnJlc2ggZXZlbnRcbiAgICAgICAgY29uc3QgcmVzRXZlbnQ6IFJlc291cmNlRXZlbnQgPSB7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIHBhcmVudFN0YWNrTG9naWNhbElkczogdGhpcy5wcm9wcy5wYXJlbnRTdGFja0xvZ2ljYWxJZHMgPz8gW10sXG4gICAgICAgICAgaXNTdGFja0V2ZW50OiBpc1BhcmVudFN0YWNrRXZlbnQsXG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50cy5wdXNoKHJlc0V2ZW50KTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWlzUGFyZW50U3RhY2tFdmVudCAmJlxuICAgICAgICAgIGV2ZW50LlJlc291cmNlVHlwZSA9PT0gJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJyAmJlxuICAgICAgICAgIGlzU3RhY2tCZWdpbk9wZXJhdGlvblN0YXRlKGV2ZW50LlJlc291cmNlU3RhdHVzKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgbm90IGZvciBgdGhpc2Agc3RhY2sgYW5kIGhhcyBhIHBoeXNpY2FsIHJlc291cmNlIElkLCByZWN1cnNpdmVseSBjYWxsIGZvciBldmVudHMgaW4gdGhlIG5lc3RlZCBzdGFja1xuICAgICAgICAgIHRoaXMudHJhY2tOZXN0ZWRTdGFjayhldmVudCwgWy4uLih0aGlzLnByb3BzLnBhcmVudFN0YWNrTG9naWNhbElkcyA/PyBbXSksIGV2ZW50LkxvZ2ljYWxSZXNvdXJjZUlkID8/ICcnXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQYXJlbnRTdGFja0V2ZW50ICYmIGlzU3RhY2tUZXJtaW5hbFN0YXRlKGV2ZW50LlJlc291cmNlU3RhdHVzKSkge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoIShlLm5hbWUgPT09ICdWYWxpZGF0aW9uRXJyb3InICYmIGUubWVzc2FnZSA9PT0gYFN0YWNrIFske3RoaXMucHJvcHMuc3RhY2tOYW1lfV0gZG9lcyBub3QgZXhpc3RgKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyAvLyBBbHNvIHBvbGwgYWxsIG5lc3RlZCBzdGFja3Mgd2UncmUgY3VycmVudGx5IHRyYWNraW5nXG4gICAgLy8gZm9yIChjb25zdCBbbG9naWNhbElkLCBwb2xsZXJdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMubmVzdGVkU3RhY2tQb2xsZXJzKSkge1xuICAgIC8vICAgZXZlbnRzLnB1c2goLi4uKGF3YWl0IHBvbGxlci5wb2xsKCkpKTtcbiAgICAvLyAgIGlmIChwb2xsZXIuY29tcGxldGUpIHtcbiAgICAvLyAgICAgZGVsZXRlIHRoaXMubmVzdGVkU3RhY2tQb2xsZXJzW2xvZ2ljYWxJZF07XG4gICAgLy8gICB9XG4gICAgLy8gfVxuXG4gICAgLy8gLy8gUmV0dXJuIHdoYXQgd2UgaGF2ZSBzbyBmYXJcbiAgICAvLyBldmVudHMuc29ydCgoYSwgYikgPT4gYS5ldmVudC5UaW1lc3RhbXAhLnZhbHVlT2YoKSAtIGIuZXZlbnQuVGltZXN0YW1wIS52YWx1ZU9mKCkpO1xuICAgIC8vIHRoaXMuZXZlbnRzLnB1c2goLi4uZXZlbnRzKTtcbiAgICByZXR1cm4gZXZlbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIE9uIHRoZSBDUkVBVEVfSU5fUFJPR1JFU1MsIFVQREFURV9JTl9QUk9HUkVTUywgREVMRVRFX0lOX1BST0dSRVNTIGV2ZW50IG9mIGEgbmVzdGVkIHN0YWNrLCBwb2xsIHRoZSBuZXN0ZWQgc3RhY2sgdXBkYXRlc1xuICAgKi9cbiAgcHJpdmF0ZSB0cmFja05lc3RlZFN0YWNrKGV2ZW50OiBTdGFja0V2ZW50LCBwYXJlbnRTdGFja0xvZ2ljYWxJZHM6IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgbG9naWNhbElkID0gZXZlbnQuTG9naWNhbFJlc291cmNlSWQ7XG4gICAgY29uc3QgcGh5c2ljYWxSZXNvdXJjZUlkID0gZXZlbnQuUGh5c2ljYWxSZXNvdXJjZUlkO1xuXG4gICAgLy8gVGhlIENSRUFURV9JTl9QUk9HUkVTUyBldmVudCBmb3IgYSBOZXN0ZWQgU3RhY2sgaXMgZW1pdHRlZCB0d2ljZTsgZmlyc3Qgd2l0aG91dCBhIFBoeXNpY2FsUmVzb3VyY2VJZFxuICAgIC8vIGFuZCB0aGVuIHdpdGguIElnbm9yZSB0aGlzIGV2ZW50IGlmIHdlIGRvbid0IGhhdmUgdGhhdCBwcm9wZXJ0eSB5ZXQuXG4gICAgLy9cbiAgICAvLyAoQXQgdGhpcyBwb2ludCwgSSBhbHNvIGRvbid0IHRydXN0IHRoYXQgbG9naWNhbElkIGlzIGFsd2F5cyBnb2luZyB0byBiZSB0aGVyZSBzbyB2YWxpZGF0ZSB0aGF0IGFzIHdlbGwpXG4gICAgaWYgKCFsb2dpY2FsSWQgfHwgIXBoeXNpY2FsUmVzb3VyY2VJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5uZXN0ZWRTdGFja1BvbGxlcnNbbG9naWNhbElkXSkge1xuICAgICAgdGhpcy5uZXN0ZWRTdGFja1BvbGxlcnNbbG9naWNhbElkXSA9IG5ldyBTdGFja0V2ZW50UG9sbGVyKHRoaXMuY2ZuLCB7XG4gICAgICAgIHN0YWNrTmFtZTogcGh5c2ljYWxSZXNvdXJjZUlkLFxuICAgICAgICBwYXJlbnRTdGFja0xvZ2ljYWxJZHM6IHBhcmVudFN0YWNrTG9naWNhbElkcyxcbiAgICAgICAgc3RhcnRUaW1lOiBldmVudC5UaW1lc3RhbXAhLnZhbHVlT2YoKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YWNrQmVnaW5PcGVyYXRpb25TdGF0ZShzdGF0ZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gIHJldHVybiBbXG4gICAgJ0NSRUFURV9JTl9QUk9HUkVTUycsXG4gICAgJ1VQREFURV9JTl9QUk9HUkVTUycsXG4gICAgJ0RFTEVURV9JTl9QUk9HUkVTUycsXG4gICAgJ1VQREFURV9ST0xMQkFDS19JTl9QUk9HUkVTUycsXG4gICAgJ1JPTExCQUNLX0lOX1BST0dSRVNTJyxcbiAgXS5pbmNsdWRlcyhzdGF0ZSA/PyAnJyk7XG59XG5cbmZ1bmN0aW9uIGlzU3RhY2tUZXJtaW5hbFN0YXRlKHN0YXRlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgcmV0dXJuICEoc3RhdGUgPz8gJycpLmVuZHNXaXRoKCdfSU5fUFJPR1JFU1MnKTtcbn1cbiJdfQ==