"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsCliCompatible = void 0;
const credential_providers_1 = require("@aws-sdk/credential-providers");
const ec2_metadata_service_1 = require("@aws-sdk/ec2-metadata-service");
const shared_ini_file_loader_1 = require("@smithy/shared-ini-file-loader");
const promptly = require("promptly");
const util_1 = require("./util");
const logging_1 = require("../../logging");
const DEFAULT_CONNECTION_TIMEOUT = 10000;
const DEFAULT_TIMEOUT = 300000;
/**
 * Behaviors to match AWS CLI
 *
 * See these links:
 *
 * https://docs.aws.amazon.com/cli/latest/topic/config-vars.html
 * https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html
 */
class AwsCliCompatible {
    /**
     * Build an AWS CLI-compatible credential chain provider
     */
    static async credentialChainBuilder(options = {}) {
        /**
         * The previous implementation matched AWS CLI behavior:
         *
         * If a profile is explicitly set using `--profile`,
         * we use that to the exclusion of everything else.
         *
         * Note: this does not apply to AWS_PROFILE,
         * environment credentials still take precedence over AWS_PROFILE
         */
        if (options.profile) {
            return (0, credential_providers_1.fromIni)({
                profile: options.profile,
                ignoreCache: true,
                mfaCodeProvider: tokenCodeFn,
                clientConfig: {
                    requestHandler: AwsCliCompatible.requestHandlerBuilder(options.httpOptions),
                    customUserAgent: 'aws-cdk',
                    logger: options.logger,
                },
                logger: options.logger,
            });
        }
        const profile = options.profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE;
        /**
         * Env AWS - EnvironmentCredentials with string AWS
         * Env Amazon - EnvironmentCredentials with string AMAZON
         * Profile Credentials - PatchedSharedIniFileCredentials with implicit profile, credentials file, http options, and token fn
         *    SSO with implicit profile only
         *    SharedIniFileCredentials with implicit profile and preferStaticCredentials true (profile with source_profile)
         *    Shared Credential file that points to Environment Credentials with AWS prefix
         *    Shared Credential file that points to EC2 Metadata
         *    Shared Credential file that points to ECS Credentials
         * SSO Credentials - SsoCredentials with implicit profile and http options
         * ProcessCredentials with implicit profile
         * ECS Credentials - ECSCredentials with no input OR Web Identity - TokenFileWebIdentityCredentials with no input OR EC2 Metadata - EC2MetadataCredentials with no input
         *
         * These translate to:
         * fromEnv()
         * fromSSO()/fromIni()
         * fromProcess()
         * fromContainerMetadata()
         * fromTokenFile()
         * fromInstanceMetadata()
         */
        const nodeProviderChain = (0, credential_providers_1.fromNodeProviderChain)({
            profile: profile,
            clientConfig: {
                requestHandler: AwsCliCompatible.requestHandlerBuilder(options.httpOptions),
                customUserAgent: 'aws-cdk',
                logger: options.logger,
            },
            logger: options.logger,
            ignoreCache: true,
        });
        return shouldPrioritizeEnv()
            ? (0, credential_providers_1.createCredentialChain)((0, credential_providers_1.fromEnv)(), nodeProviderChain).expireAfter(60 * 60000)
            : nodeProviderChain;
    }
    static requestHandlerBuilder(options = {}) {
        const config = {
            connectionTimeout: DEFAULT_CONNECTION_TIMEOUT,
            requestTimeout: DEFAULT_TIMEOUT,
            httpsAgent: {
                ca: tryGetCACert(options.caBundlePath),
                localAddress: options.proxyAddress,
            },
            httpAgent: {
                localAddress: options.proxyAddress,
            },
        };
        return config;
    }
    /**
     * Attempts to get the region from a number of sources and falls back to us-east-1 if no region can be found,
     * as is done in the AWS CLI.
     *
     * The order of priority is the following:
     *
     * 1. Environment variables specifying region, with both an AWS prefix and AMAZON prefix
     *    to maintain backwards compatibility, and without `DEFAULT` in the name because
     *    Lambda and CodeBuild set the $AWS_REGION variable.
     * 2. Regions listed in the Shared Ini Files - First checking for the profile provided
     *    and then checking for the default profile.
     * 3. IMDS instance identity region from the Metadata Service.
     * 4. us-east-1
     */
    static async region(maybeProfile) {
        const defaultRegion = 'us-east-1';
        const profile = maybeProfile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
        const region = process.env.AWS_REGION ||
            process.env.AMAZON_REGION ||
            process.env.AWS_DEFAULT_REGION ||
            process.env.AMAZON_DEFAULT_REGION ||
            (await getRegionFromIni(profile)) ||
            (await regionFromMetadataService());
        if (!region) {
            const usedProfile = !profile ? '' : ` (profile: "${profile}")`;
            (0, logging_1.debug)(`Unable to determine AWS region from environment or AWS configuration${usedProfile}, defaulting to '${defaultRegion}'`);
            return defaultRegion;
        }
        return region;
    }
}
exports.AwsCliCompatible = AwsCliCompatible;
/**
 * Looks up the region of the provided profile. If no region is present,
 * it will attempt to lookup the default region.
 * @param profile The profile to use to lookup the region
 * @returns The region for the profile or default profile, if present. Otherwise returns undefined.
 */
async function getRegionFromIni(profile) {
    const sharedFiles = await (0, shared_ini_file_loader_1.loadSharedConfigFiles)({ ignoreCache: true });
    return sharedFiles?.configFile?.[profile]?.region || sharedFiles?.configFile?.default?.region;
}
function tryGetCACert(bundlePath) {
    const path = bundlePath || caBundlePathFromEnvironment();
    if (path) {
        (0, logging_1.debug)('Using CA bundle path: %s', bundlePath);
        return (0, util_1.readIfPossible)(path);
    }
    return undefined;
}
/**
 * Find and return a CA certificate bundle path to be passed into the SDK.
 */
function caBundlePathFromEnvironment() {
    if (process.env.aws_ca_bundle) {
        return process.env.aws_ca_bundle;
    }
    if (process.env.AWS_CA_BUNDLE) {
        return process.env.AWS_CA_BUNDLE;
    }
    return undefined;
}
/**
 * We used to support both AWS and AMAZON prefixes for these environment variables.
 *
 * Adding this for backward compatibility.
 */
function shouldPrioritizeEnv() {
    const id = process.env.AWS_ACCESS_KEY_ID || process.env.AMAZON_ACCESS_KEY_ID;
    const key = process.env.AWS_SECRET_ACCESS_KEY || process.env.AMAZON_SECRET_ACCESS_KEY;
    process.env.AWS_SESSION_TOKEN = process.env.AWS_SESSION_TOKEN || process.env.AMAZON_SESSION_TOKEN;
    if (!!id && !!key) {
        process.env.AWS_ACCESS_KEY_ID = id;
        process.env.AWS_SECRET_ACCESS_KEY = key;
        return true;
    }
    return false;
}
/**
 * The MetadataService class will attempt to fetch the instance identity document from
 * IMDSv2 first, and then will attempt v1 as a fallback.
 *
 * If this fails, we will use us-east-1 as the region so no error should be thrown.
 * @returns The region for the instance identity
 */
async function regionFromMetadataService() {
    (0, logging_1.debug)('Looking up AWS region in the EC2 Instance Metadata Service (IMDS).');
    try {
        const metadataService = new ec2_metadata_service_1.MetadataService({
            httpOptions: {
                timeout: 1000,
            },
        });
        await metadataService.fetchMetadataToken();
        const document = await metadataService.request('/latest/dynamic/instance-identity/document', {});
        return JSON.parse(document).region;
    }
    catch (e) {
        (0, logging_1.debug)(`Unable to retrieve AWS region from IMDS: ${e}`);
    }
}
/**
 * Ask user for MFA token for given serial
 *
 * Result is send to callback function for SDK to authorize the request
 */
async function tokenCodeFn(serialArn) {
    (0, logging_1.debug)('Require MFA token for serial ARN', serialArn);
    try {
        const token = await promptly.prompt(`MFA token for ${serialArn}: `, {
            trim: true,
            default: '',
        });
        (0, logging_1.debug)('Successfully got MFA token from user');
        return token;
    }
    catch (err) {
        (0, logging_1.debug)('Failed to get MFA token', err);
        const e = new Error(`Error fetching MFA token: ${err.message ?? err}`);
        e.name = 'SharedIniFileCredentialsProviderFailure';
        throw e;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXdzY2xpLWNvbXBhdGlibGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJhd3NjbGktY29tcGF0aWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx3RUFBK0c7QUFDL0csd0VBQWdFO0FBRWhFLDJFQUF1RTtBQUV2RSxxQ0FBcUM7QUFFckMsaUNBQXdDO0FBQ3hDLDJDQUFzQztBQUV0QyxNQUFNLDBCQUEwQixHQUFHLEtBQUssQ0FBQztBQUN6QyxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUM7QUFFL0I7Ozs7Ozs7R0FPRztBQUNILE1BQWEsZ0JBQWdCO0lBQzNCOztPQUVHO0lBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQyxzQkFBc0IsQ0FDeEMsVUFBa0MsRUFBRTtRQUVwQzs7Ozs7Ozs7V0FRRztRQUNILElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3BCLE9BQU8sSUFBQSw4QkFBTyxFQUFDO2dCQUNiLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTztnQkFDeEIsV0FBVyxFQUFFLElBQUk7Z0JBQ2pCLGVBQWUsRUFBRSxXQUFXO2dCQUM1QixZQUFZLEVBQUU7b0JBQ1osY0FBYyxFQUFFLGdCQUFnQixDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUM7b0JBQzNFLGVBQWUsRUFBRSxTQUFTO29CQUMxQixNQUFNLEVBQUUsT0FBTyxDQUFDLE1BQU07aUJBQ3ZCO2dCQUNELE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTTthQUN2QixDQUFDLENBQUM7UUFDTCxDQUFDO1FBRUQsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDO1FBRTlGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQW9CRztRQUNILE1BQU0saUJBQWlCLEdBQUcsSUFBQSw0Q0FBcUIsRUFBQztZQUM5QyxPQUFPLEVBQUUsT0FBTztZQUNoQixZQUFZLEVBQUU7Z0JBQ1osY0FBYyxFQUFFLGdCQUFnQixDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUM7Z0JBQzNFLGVBQWUsRUFBRSxTQUFTO2dCQUMxQixNQUFNLEVBQUUsT0FBTyxDQUFDLE1BQU07YUFDdkI7WUFDRCxNQUFNLEVBQUUsT0FBTyxDQUFDLE1BQU07WUFDdEIsV0FBVyxFQUFFLElBQUk7U0FDbEIsQ0FBQyxDQUFDO1FBRUgsT0FBTyxtQkFBbUIsRUFBRTtZQUMxQixDQUFDLENBQUMsSUFBQSw0Q0FBcUIsRUFBQyxJQUFBLDhCQUFPLEdBQUUsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxFQUFFLEdBQUcsS0FBTSxDQUFDO1lBQzlFLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQztJQUN4QixDQUFDO0lBRU0sTUFBTSxDQUFDLHFCQUFxQixDQUFDLFVBQTBCLEVBQUU7UUFDOUQsTUFBTSxNQUFNLEdBQTJCO1lBQ3JDLGlCQUFpQixFQUFFLDBCQUEwQjtZQUM3QyxjQUFjLEVBQUUsZUFBZTtZQUMvQixVQUFVLEVBQUU7Z0JBQ1YsRUFBRSxFQUFFLFlBQVksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDO2dCQUN0QyxZQUFZLEVBQUUsT0FBTyxDQUFDLFlBQVk7YUFDbkM7WUFDRCxTQUFTLEVBQUU7Z0JBQ1QsWUFBWSxFQUFFLE9BQU8sQ0FBQyxZQUFZO2FBQ25DO1NBQ0YsQ0FBQztRQUNGLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsWUFBcUI7UUFDOUMsTUFBTSxhQUFhLEdBQUcsV0FBVyxDQUFDO1FBQ2xDLE1BQU0sT0FBTyxHQUFHLFlBQVksSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixJQUFJLFNBQVMsQ0FBQztRQUV4RyxNQUFNLE1BQU0sR0FDVixPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVU7WUFDdEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhO1lBQ3pCLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCO1lBQzlCLE9BQU8sQ0FBQyxHQUFHLENBQUMscUJBQXFCO1lBQ2pDLENBQUMsTUFBTSxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNqQyxDQUFDLE1BQU0seUJBQXlCLEVBQUUsQ0FBQyxDQUFDO1FBRXRDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNaLE1BQU0sV0FBVyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLGVBQWUsT0FBTyxJQUFJLENBQUM7WUFDL0QsSUFBQSxlQUFLLEVBQ0gsdUVBQXVFLFdBQVcsb0JBQW9CLGFBQWEsR0FBRyxDQUN2SCxDQUFDO1lBQ0YsT0FBTyxhQUFhLENBQUM7UUFDdkIsQ0FBQztRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7Q0FDRjtBQXhIRCw0Q0F3SEM7QUFFRDs7Ozs7R0FLRztBQUNILEtBQUssVUFBVSxnQkFBZ0IsQ0FBQyxPQUFlO0lBQzdDLE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBQSw4Q0FBcUIsRUFBQyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZFLE9BQU8sV0FBVyxFQUFFLFVBQVUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLE1BQU0sSUFBSSxXQUFXLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUM7QUFDaEcsQ0FBQztBQUVELFNBQVMsWUFBWSxDQUFDLFVBQW1CO0lBQ3ZDLE1BQU0sSUFBSSxHQUFHLFVBQVUsSUFBSSwyQkFBMkIsRUFBRSxDQUFDO0lBQ3pELElBQUksSUFBSSxFQUFFLENBQUM7UUFDVCxJQUFBLGVBQUssRUFBQywwQkFBMEIsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUM5QyxPQUFPLElBQUEscUJBQWMsRUFBQyxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBQ0QsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUywyQkFBMkI7SUFDbEMsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQzlCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUM7SUFDbkMsQ0FBQztJQUNELElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUM5QixPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDO0lBQ25DLENBQUM7SUFDRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsbUJBQW1CO0lBQzFCLE1BQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQztJQUM3RSxNQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQixJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0JBQXdCLENBQUM7SUFDdEYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLGlCQUFpQixJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsb0JBQW9CLENBQUM7SUFFbEcsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNsQixPQUFPLENBQUMsR0FBRyxDQUFDLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztRQUNuQyxPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQixHQUFHLEdBQUcsQ0FBQztRQUN4QyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxLQUFLLFVBQVUseUJBQXlCO0lBQ3RDLElBQUEsZUFBSyxFQUFDLG9FQUFvRSxDQUFDLENBQUM7SUFDNUUsSUFBSSxDQUFDO1FBQ0gsTUFBTSxlQUFlLEdBQUcsSUFBSSxzQ0FBZSxDQUFDO1lBQzFDLFdBQVcsRUFBRTtnQkFDWCxPQUFPLEVBQUUsSUFBSTthQUNkO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsTUFBTSxlQUFlLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUMzQyxNQUFNLFFBQVEsR0FBRyxNQUFNLGVBQWUsQ0FBQyxPQUFPLENBQUMsNENBQTRDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDakcsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQztJQUNyQyxDQUFDO0lBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztRQUNYLElBQUEsZUFBSyxFQUFDLDRDQUE0QyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3pELENBQUM7QUFDSCxDQUFDO0FBUUQ7Ozs7R0FJRztBQUNILEtBQUssVUFBVSxXQUFXLENBQUMsU0FBaUI7SUFDMUMsSUFBQSxlQUFLLEVBQUMsa0NBQWtDLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDckQsSUFBSSxDQUFDO1FBQ0gsTUFBTSxLQUFLLEdBQVcsTUFBTSxRQUFRLENBQUMsTUFBTSxDQUFDLGlCQUFpQixTQUFTLElBQUksRUFBRTtZQUMxRSxJQUFJLEVBQUUsSUFBSTtZQUNWLE9BQU8sRUFBRSxFQUFFO1NBQ1osQ0FBQyxDQUFDO1FBQ0gsSUFBQSxlQUFLLEVBQUMsc0NBQXNDLENBQUMsQ0FBQztRQUM5QyxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFBQyxPQUFPLEdBQVEsRUFBRSxDQUFDO1FBQ2xCLElBQUEsZUFBSyxFQUFDLHlCQUF5QixFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sQ0FBQyxHQUFHLElBQUksS0FBSyxDQUFDLDZCQUE2QixHQUFHLENBQUMsT0FBTyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDdkUsQ0FBQyxDQUFDLElBQUksR0FBRyx5Q0FBeUMsQ0FBQztRQUNuRCxNQUFNLENBQUMsQ0FBQztJQUNWLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ3JlZGVudGlhbENoYWluLCBmcm9tRW52LCBmcm9tSW5pLCBmcm9tTm9kZVByb3ZpZGVyQ2hhaW4gfSBmcm9tICdAYXdzLXNkay9jcmVkZW50aWFsLXByb3ZpZGVycyc7XG5pbXBvcnQgeyBNZXRhZGF0YVNlcnZpY2UgfSBmcm9tICdAYXdzLXNkay9lYzItbWV0YWRhdGEtc2VydmljZSc7XG5pbXBvcnQgdHlwZSB7IE5vZGVIdHRwSGFuZGxlck9wdGlvbnMgfSBmcm9tICdAc21pdGh5L25vZGUtaHR0cC1oYW5kbGVyJztcbmltcG9ydCB7IGxvYWRTaGFyZWRDb25maWdGaWxlcyB9IGZyb20gJ0BzbWl0aHkvc2hhcmVkLWluaS1maWxlLWxvYWRlcic7XG5pbXBvcnQgeyBBd3NDcmVkZW50aWFsSWRlbnRpdHlQcm92aWRlciwgTG9nZ2VyIH0gZnJvbSAnQHNtaXRoeS90eXBlcyc7XG5pbXBvcnQgKiBhcyBwcm9tcHRseSBmcm9tICdwcm9tcHRseSc7XG5pbXBvcnQgdHlwZSB7IFNka0h0dHBPcHRpb25zIH0gZnJvbSAnLi9zZGstcHJvdmlkZXInO1xuaW1wb3J0IHsgcmVhZElmUG9zc2libGUgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcblxuY29uc3QgREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAxMDAwMDtcbmNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDMwMDAwMDtcblxuLyoqXG4gKiBCZWhhdmlvcnMgdG8gbWF0Y2ggQVdTIENMSVxuICpcbiAqIFNlZSB0aGVzZSBsaW5rczpcbiAqXG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2xpL2xhdGVzdC90b3BpYy9jb25maWctdmFycy5odG1sXG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2xpL2xhdGVzdC91c2VyZ3VpZGUvY2xpLWNvbmZpZ3VyZS1lbnZ2YXJzLmh0bWxcbiAqL1xuZXhwb3J0IGNsYXNzIEF3c0NsaUNvbXBhdGlibGUge1xuICAvKipcbiAgICogQnVpbGQgYW4gQVdTIENMSS1jb21wYXRpYmxlIGNyZWRlbnRpYWwgY2hhaW4gcHJvdmlkZXJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgY3JlZGVudGlhbENoYWluQnVpbGRlcihcbiAgICBvcHRpb25zOiBDcmVkZW50aWFsQ2hhaW5PcHRpb25zID0ge30sXG4gICk6IFByb21pc2U8QXdzQ3JlZGVudGlhbElkZW50aXR5UHJvdmlkZXI+IHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJldmlvdXMgaW1wbGVtZW50YXRpb24gbWF0Y2hlZCBBV1MgQ0xJIGJlaGF2aW9yOlxuICAgICAqXG4gICAgICogSWYgYSBwcm9maWxlIGlzIGV4cGxpY2l0bHkgc2V0IHVzaW5nIGAtLXByb2ZpbGVgLFxuICAgICAqIHdlIHVzZSB0aGF0IHRvIHRoZSBleGNsdXNpb24gb2YgZXZlcnl0aGluZyBlbHNlLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBkb2VzIG5vdCBhcHBseSB0byBBV1NfUFJPRklMRSxcbiAgICAgKiBlbnZpcm9ubWVudCBjcmVkZW50aWFscyBzdGlsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBBV1NfUFJPRklMRVxuICAgICAqL1xuICAgIGlmIChvcHRpb25zLnByb2ZpbGUpIHtcbiAgICAgIHJldHVybiBmcm9tSW5pKHtcbiAgICAgICAgcHJvZmlsZTogb3B0aW9ucy5wcm9maWxlLFxuICAgICAgICBpZ25vcmVDYWNoZTogdHJ1ZSxcbiAgICAgICAgbWZhQ29kZVByb3ZpZGVyOiB0b2tlbkNvZGVGbixcbiAgICAgICAgY2xpZW50Q29uZmlnOiB7XG4gICAgICAgICAgcmVxdWVzdEhhbmRsZXI6IEF3c0NsaUNvbXBhdGlibGUucmVxdWVzdEhhbmRsZXJCdWlsZGVyKG9wdGlvbnMuaHR0cE9wdGlvbnMpLFxuICAgICAgICAgIGN1c3RvbVVzZXJBZ2VudDogJ2F3cy1jZGsnLFxuICAgICAgICAgIGxvZ2dlcjogb3B0aW9ucy5sb2dnZXIsXG4gICAgICAgIH0sXG4gICAgICAgIGxvZ2dlcjogb3B0aW9ucy5sb2dnZXIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9maWxlID0gb3B0aW9ucy5wcm9maWxlIHx8IHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1BST0ZJTEU7XG5cbiAgICAvKipcbiAgICAgKiBFbnYgQVdTIC0gRW52aXJvbm1lbnRDcmVkZW50aWFscyB3aXRoIHN0cmluZyBBV1NcbiAgICAgKiBFbnYgQW1hem9uIC0gRW52aXJvbm1lbnRDcmVkZW50aWFscyB3aXRoIHN0cmluZyBBTUFaT05cbiAgICAgKiBQcm9maWxlIENyZWRlbnRpYWxzIC0gUGF0Y2hlZFNoYXJlZEluaUZpbGVDcmVkZW50aWFscyB3aXRoIGltcGxpY2l0IHByb2ZpbGUsIGNyZWRlbnRpYWxzIGZpbGUsIGh0dHAgb3B0aW9ucywgYW5kIHRva2VuIGZuXG4gICAgICogICAgU1NPIHdpdGggaW1wbGljaXQgcHJvZmlsZSBvbmx5XG4gICAgICogICAgU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzIHdpdGggaW1wbGljaXQgcHJvZmlsZSBhbmQgcHJlZmVyU3RhdGljQ3JlZGVudGlhbHMgdHJ1ZSAocHJvZmlsZSB3aXRoIHNvdXJjZV9wcm9maWxlKVxuICAgICAqICAgIFNoYXJlZCBDcmVkZW50aWFsIGZpbGUgdGhhdCBwb2ludHMgdG8gRW52aXJvbm1lbnQgQ3JlZGVudGlhbHMgd2l0aCBBV1MgcHJlZml4XG4gICAgICogICAgU2hhcmVkIENyZWRlbnRpYWwgZmlsZSB0aGF0IHBvaW50cyB0byBFQzIgTWV0YWRhdGFcbiAgICAgKiAgICBTaGFyZWQgQ3JlZGVudGlhbCBmaWxlIHRoYXQgcG9pbnRzIHRvIEVDUyBDcmVkZW50aWFsc1xuICAgICAqIFNTTyBDcmVkZW50aWFscyAtIFNzb0NyZWRlbnRpYWxzIHdpdGggaW1wbGljaXQgcHJvZmlsZSBhbmQgaHR0cCBvcHRpb25zXG4gICAgICogUHJvY2Vzc0NyZWRlbnRpYWxzIHdpdGggaW1wbGljaXQgcHJvZmlsZVxuICAgICAqIEVDUyBDcmVkZW50aWFscyAtIEVDU0NyZWRlbnRpYWxzIHdpdGggbm8gaW5wdXQgT1IgV2ViIElkZW50aXR5IC0gVG9rZW5GaWxlV2ViSWRlbnRpdHlDcmVkZW50aWFscyB3aXRoIG5vIGlucHV0IE9SIEVDMiBNZXRhZGF0YSAtIEVDMk1ldGFkYXRhQ3JlZGVudGlhbHMgd2l0aCBubyBpbnB1dFxuICAgICAqXG4gICAgICogVGhlc2UgdHJhbnNsYXRlIHRvOlxuICAgICAqIGZyb21FbnYoKVxuICAgICAqIGZyb21TU08oKS9mcm9tSW5pKClcbiAgICAgKiBmcm9tUHJvY2VzcygpXG4gICAgICogZnJvbUNvbnRhaW5lck1ldGFkYXRhKClcbiAgICAgKiBmcm9tVG9rZW5GaWxlKClcbiAgICAgKiBmcm9tSW5zdGFuY2VNZXRhZGF0YSgpXG4gICAgICovXG4gICAgY29uc3Qgbm9kZVByb3ZpZGVyQ2hhaW4gPSBmcm9tTm9kZVByb3ZpZGVyQ2hhaW4oe1xuICAgICAgcHJvZmlsZTogcHJvZmlsZSxcbiAgICAgIGNsaWVudENvbmZpZzoge1xuICAgICAgICByZXF1ZXN0SGFuZGxlcjogQXdzQ2xpQ29tcGF0aWJsZS5yZXF1ZXN0SGFuZGxlckJ1aWxkZXIob3B0aW9ucy5odHRwT3B0aW9ucyksXG4gICAgICAgIGN1c3RvbVVzZXJBZ2VudDogJ2F3cy1jZGsnLFxuICAgICAgICBsb2dnZXI6IG9wdGlvbnMubG9nZ2VyLFxuICAgICAgfSxcbiAgICAgIGxvZ2dlcjogb3B0aW9ucy5sb2dnZXIsXG4gICAgICBpZ25vcmVDYWNoZTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIHJldHVybiBzaG91bGRQcmlvcml0aXplRW52KClcbiAgICAgID8gY3JlYXRlQ3JlZGVudGlhbENoYWluKGZyb21FbnYoKSwgbm9kZVByb3ZpZGVyQ2hhaW4pLmV4cGlyZUFmdGVyKDYwICogNjBfMDAwKVxuICAgICAgOiBub2RlUHJvdmlkZXJDaGFpbjtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcmVxdWVzdEhhbmRsZXJCdWlsZGVyKG9wdGlvbnM6IFNka0h0dHBPcHRpb25zID0ge30pOiBOb2RlSHR0cEhhbmRsZXJPcHRpb25zIHtcbiAgICBjb25zdCBjb25maWc6IE5vZGVIdHRwSGFuZGxlck9wdGlvbnMgPSB7XG4gICAgICBjb25uZWN0aW9uVGltZW91dDogREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgICByZXF1ZXN0VGltZW91dDogREVGQVVMVF9USU1FT1VULFxuICAgICAgaHR0cHNBZ2VudDoge1xuICAgICAgICBjYTogdHJ5R2V0Q0FDZXJ0KG9wdGlvbnMuY2FCdW5kbGVQYXRoKSxcbiAgICAgICAgbG9jYWxBZGRyZXNzOiBvcHRpb25zLnByb3h5QWRkcmVzcyxcbiAgICAgIH0sXG4gICAgICBodHRwQWdlbnQ6IHtcbiAgICAgICAgbG9jYWxBZGRyZXNzOiBvcHRpb25zLnByb3h5QWRkcmVzcyxcbiAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGdldCB0aGUgcmVnaW9uIGZyb20gYSBudW1iZXIgb2Ygc291cmNlcyBhbmQgZmFsbHMgYmFjayB0byB1cy1lYXN0LTEgaWYgbm8gcmVnaW9uIGNhbiBiZSBmb3VuZCxcbiAgICogYXMgaXMgZG9uZSBpbiB0aGUgQVdTIENMSS5cbiAgICpcbiAgICogVGhlIG9yZGVyIG9mIHByaW9yaXR5IGlzIHRoZSBmb2xsb3dpbmc6XG4gICAqXG4gICAqIDEuIEVudmlyb25tZW50IHZhcmlhYmxlcyBzcGVjaWZ5aW5nIHJlZ2lvbiwgd2l0aCBib3RoIGFuIEFXUyBwcmVmaXggYW5kIEFNQVpPTiBwcmVmaXhcbiAgICogICAgdG8gbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB3aXRob3V0IGBERUZBVUxUYCBpbiB0aGUgbmFtZSBiZWNhdXNlXG4gICAqICAgIExhbWJkYSBhbmQgQ29kZUJ1aWxkIHNldCB0aGUgJEFXU19SRUdJT04gdmFyaWFibGUuXG4gICAqIDIuIFJlZ2lvbnMgbGlzdGVkIGluIHRoZSBTaGFyZWQgSW5pIEZpbGVzIC0gRmlyc3QgY2hlY2tpbmcgZm9yIHRoZSBwcm9maWxlIHByb3ZpZGVkXG4gICAqICAgIGFuZCB0aGVuIGNoZWNraW5nIGZvciB0aGUgZGVmYXVsdCBwcm9maWxlLlxuICAgKiAzLiBJTURTIGluc3RhbmNlIGlkZW50aXR5IHJlZ2lvbiBmcm9tIHRoZSBNZXRhZGF0YSBTZXJ2aWNlLlxuICAgKiA0LiB1cy1lYXN0LTFcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgcmVnaW9uKG1heWJlUHJvZmlsZT86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgZGVmYXVsdFJlZ2lvbiA9ICd1cy1lYXN0LTEnO1xuICAgIGNvbnN0IHByb2ZpbGUgPSBtYXliZVByb2ZpbGUgfHwgcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUFJPRklMRSB8fCAnZGVmYXVsdCc7XG5cbiAgICBjb25zdCByZWdpb24gPVxuICAgICAgcHJvY2Vzcy5lbnYuQVdTX1JFR0lPTiB8fFxuICAgICAgcHJvY2Vzcy5lbnYuQU1BWk9OX1JFR0lPTiB8fFxuICAgICAgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUkVHSU9OIHx8XG4gICAgICBwcm9jZXNzLmVudi5BTUFaT05fREVGQVVMVF9SRUdJT04gfHxcbiAgICAgIChhd2FpdCBnZXRSZWdpb25Gcm9tSW5pKHByb2ZpbGUpKSB8fFxuICAgICAgKGF3YWl0IHJlZ2lvbkZyb21NZXRhZGF0YVNlcnZpY2UoKSk7XG5cbiAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgY29uc3QgdXNlZFByb2ZpbGUgPSAhcHJvZmlsZSA/ICcnIDogYCAocHJvZmlsZTogXCIke3Byb2ZpbGV9XCIpYDtcbiAgICAgIGRlYnVnKFxuICAgICAgICBgVW5hYmxlIHRvIGRldGVybWluZSBBV1MgcmVnaW9uIGZyb20gZW52aXJvbm1lbnQgb3IgQVdTIGNvbmZpZ3VyYXRpb24ke3VzZWRQcm9maWxlfSwgZGVmYXVsdGluZyB0byAnJHtkZWZhdWx0UmVnaW9ufSdgLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkZWZhdWx0UmVnaW9uO1xuICAgIH1cblxuICAgIHJldHVybiByZWdpb247XG4gIH1cbn1cblxuLyoqXG4gKiBMb29rcyB1cCB0aGUgcmVnaW9uIG9mIHRoZSBwcm92aWRlZCBwcm9maWxlLiBJZiBubyByZWdpb24gaXMgcHJlc2VudCxcbiAqIGl0IHdpbGwgYXR0ZW1wdCB0byBsb29rdXAgdGhlIGRlZmF1bHQgcmVnaW9uLlxuICogQHBhcmFtIHByb2ZpbGUgVGhlIHByb2ZpbGUgdG8gdXNlIHRvIGxvb2t1cCB0aGUgcmVnaW9uXG4gKiBAcmV0dXJucyBUaGUgcmVnaW9uIGZvciB0aGUgcHJvZmlsZSBvciBkZWZhdWx0IHByb2ZpbGUsIGlmIHByZXNlbnQuIE90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmVnaW9uRnJvbUluaShwcm9maWxlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBzaGFyZWRGaWxlcyA9IGF3YWl0IGxvYWRTaGFyZWRDb25maWdGaWxlcyh7IGlnbm9yZUNhY2hlOiB0cnVlIH0pO1xuICByZXR1cm4gc2hhcmVkRmlsZXM/LmNvbmZpZ0ZpbGU/Lltwcm9maWxlXT8ucmVnaW9uIHx8IHNoYXJlZEZpbGVzPy5jb25maWdGaWxlPy5kZWZhdWx0Py5yZWdpb247XG59XG5cbmZ1bmN0aW9uIHRyeUdldENBQ2VydChidW5kbGVQYXRoPzogc3RyaW5nKSB7XG4gIGNvbnN0IHBhdGggPSBidW5kbGVQYXRoIHx8IGNhQnVuZGxlUGF0aEZyb21FbnZpcm9ubWVudCgpO1xuICBpZiAocGF0aCkge1xuICAgIGRlYnVnKCdVc2luZyBDQSBidW5kbGUgcGF0aDogJXMnLCBidW5kbGVQYXRoKTtcbiAgICByZXR1cm4gcmVhZElmUG9zc2libGUocGF0aCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gYSBDQSBjZXJ0aWZpY2F0ZSBidW5kbGUgcGF0aCB0byBiZSBwYXNzZWQgaW50byB0aGUgU0RLLlxuICovXG5mdW5jdGlvbiBjYUJ1bmRsZVBhdGhGcm9tRW52aXJvbm1lbnQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHByb2Nlc3MuZW52LmF3c19jYV9idW5kbGUpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuYXdzX2NhX2J1bmRsZTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuQVdTX0NBX0JVTkRMRSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5BV1NfQ0FfQlVORExFO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogV2UgdXNlZCB0byBzdXBwb3J0IGJvdGggQVdTIGFuZCBBTUFaT04gcHJlZml4ZXMgZm9yIHRoZXNlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiBBZGRpbmcgdGhpcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkUHJpb3JpdGl6ZUVudigpIHtcbiAgY29uc3QgaWQgPSBwcm9jZXNzLmVudi5BV1NfQUNDRVNTX0tFWV9JRCB8fCBwcm9jZXNzLmVudi5BTUFaT05fQUNDRVNTX0tFWV9JRDtcbiAgY29uc3Qga2V5ID0gcHJvY2Vzcy5lbnYuQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZIHx8IHByb2Nlc3MuZW52LkFNQVpPTl9TRUNSRVRfQUNDRVNTX0tFWTtcbiAgcHJvY2Vzcy5lbnYuQVdTX1NFU1NJT05fVE9LRU4gPSBwcm9jZXNzLmVudi5BV1NfU0VTU0lPTl9UT0tFTiB8fCBwcm9jZXNzLmVudi5BTUFaT05fU0VTU0lPTl9UT0tFTjtcblxuICBpZiAoISFpZCAmJiAhIWtleSkge1xuICAgIHByb2Nlc3MuZW52LkFXU19BQ0NFU1NfS0VZX0lEID0gaWQ7XG4gICAgcHJvY2Vzcy5lbnYuQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZID0ga2V5O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBNZXRhZGF0YVNlcnZpY2UgY2xhc3Mgd2lsbCBhdHRlbXB0IHRvIGZldGNoIHRoZSBpbnN0YW5jZSBpZGVudGl0eSBkb2N1bWVudCBmcm9tXG4gKiBJTURTdjIgZmlyc3QsIGFuZCB0aGVuIHdpbGwgYXR0ZW1wdCB2MSBhcyBhIGZhbGxiYWNrLlxuICpcbiAqIElmIHRoaXMgZmFpbHMsIHdlIHdpbGwgdXNlIHVzLWVhc3QtMSBhcyB0aGUgcmVnaW9uIHNvIG5vIGVycm9yIHNob3VsZCBiZSB0aHJvd24uXG4gKiBAcmV0dXJucyBUaGUgcmVnaW9uIGZvciB0aGUgaW5zdGFuY2UgaWRlbnRpdHlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVnaW9uRnJvbU1ldGFkYXRhU2VydmljZSgpIHtcbiAgZGVidWcoJ0xvb2tpbmcgdXAgQVdTIHJlZ2lvbiBpbiB0aGUgRUMyIEluc3RhbmNlIE1ldGFkYXRhIFNlcnZpY2UgKElNRFMpLicpO1xuICB0cnkge1xuICAgIGNvbnN0IG1ldGFkYXRhU2VydmljZSA9IG5ldyBNZXRhZGF0YVNlcnZpY2Uoe1xuICAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICAgICAgdGltZW91dDogMTAwMCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBhd2FpdCBtZXRhZGF0YVNlcnZpY2UuZmV0Y2hNZXRhZGF0YVRva2VuKCk7XG4gICAgY29uc3QgZG9jdW1lbnQgPSBhd2FpdCBtZXRhZGF0YVNlcnZpY2UucmVxdWVzdCgnL2xhdGVzdC9keW5hbWljL2luc3RhbmNlLWlkZW50aXR5L2RvY3VtZW50Jywge30pO1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRvY3VtZW50KS5yZWdpb247XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhgVW5hYmxlIHRvIHJldHJpZXZlIEFXUyByZWdpb24gZnJvbSBJTURTOiAke2V9YCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVkZW50aWFsQ2hhaW5PcHRpb25zIHtcbiAgcmVhZG9ubHkgcHJvZmlsZT86IHN0cmluZztcbiAgcmVhZG9ubHkgaHR0cE9wdGlvbnM/OiBTZGtIdHRwT3B0aW9ucztcbiAgcmVhZG9ubHkgbG9nZ2VyPzogTG9nZ2VyO1xufVxuXG4vKipcbiAqIEFzayB1c2VyIGZvciBNRkEgdG9rZW4gZm9yIGdpdmVuIHNlcmlhbFxuICpcbiAqIFJlc3VsdCBpcyBzZW5kIHRvIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBTREsgdG8gYXV0aG9yaXplIHRoZSByZXF1ZXN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRva2VuQ29kZUZuKHNlcmlhbEFybjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgZGVidWcoJ1JlcXVpcmUgTUZBIHRva2VuIGZvciBzZXJpYWwgQVJOJywgc2VyaWFsQXJuKTtcbiAgdHJ5IHtcbiAgICBjb25zdCB0b2tlbjogc3RyaW5nID0gYXdhaXQgcHJvbXB0bHkucHJvbXB0KGBNRkEgdG9rZW4gZm9yICR7c2VyaWFsQXJufTogYCwge1xuICAgICAgdHJpbTogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6ICcnLFxuICAgIH0pO1xuICAgIGRlYnVnKCdTdWNjZXNzZnVsbHkgZ290IE1GQSB0b2tlbiBmcm9tIHVzZXInKTtcbiAgICByZXR1cm4gdG9rZW47XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgZGVidWcoJ0ZhaWxlZCB0byBnZXQgTUZBIHRva2VuJywgZXJyKTtcbiAgICBjb25zdCBlID0gbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyBNRkEgdG9rZW46ICR7ZXJyLm1lc3NhZ2UgPz8gZXJyfWApO1xuICAgIGUubmFtZSA9ICdTaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHNQcm92aWRlckZhaWx1cmUnO1xuICAgIHRocm93IGU7XG4gIH1cbn1cbiJdfQ==